<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: src/include/lwip/priv/tcp_priv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">lwIP<span id="projectnumber">&#160;2.2.0</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tcp__priv_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">tcp_priv.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcp_8h.html">lwip/tcp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem_8h.html">lwip/mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pbuf_8h.html">lwip/pbuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip_8h.html">lwip/ip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="icmp_8h.html">lwip/icmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="err_8h.html">lwip/err.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6_8h.html">lwip/ip6.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6__addr_8h.html">lwip/ip6_addr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="prot_2tcp_8h.html">lwip/prot/tcp.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afbd7a2997e3a3b7569efc3298e2e409f" id="r_afbd7a2997e3a3b7569efc3298e2e409f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbd7a2997e3a3b7569efc3298e2e409f">tcp_do_output_nagle</a>(tpcb)</td></tr>
<tr class="separator:afbd7a2997e3a3b7569efc3298e2e409f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dbdaeac3e25f5badf3a763a1b0b990" id="r_ac9dbdaeac3e25f5badf3a763a1b0b990"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9dbdaeac3e25f5badf3a763a1b0b990">TF_RESET</a>&#160;&#160;&#160;(u8_t)0x08U   /* Connection was reset. */</td></tr>
<tr class="separator:ac9dbdaeac3e25f5badf3a763a1b0b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a6e9966d03c3326b9e0568666bb69" id="r_a178a6e9966d03c3326b9e0568666bb69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a178a6e9966d03c3326b9e0568666bb69">TCP_OVERSIZE_DBGCHECK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a178a6e9966d03c3326b9e0568666bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c47b916a8a25f82d2063335033aee" id="r_aea0c47b916a8a25f82d2063335033aee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea0c47b916a8a25f82d2063335033aee">TCP_CHECKSUM_ON_COPY</a>&#160;&#160;&#160;(<a class="el" href="group__lwip__opts__checksum.html#ga9f60183f0442bdbeefd6b395c6647613">LWIP_CHECKSUM_ON_COPY</a> &amp;&amp; <a class="el" href="group__lwip__opts__checksum.html#ga800069963cc4552b99235237c22f00bb">CHECKSUM_GEN_TCP</a>)</td></tr>
<tr class="separator:aea0c47b916a8a25f82d2063335033aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc99c343efc6c81abf60bb62b361dd8" id="r_abdc99c343efc6c81abf60bb62b361dd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc99c343efc6c81abf60bb62b361dd8">TCP_BUILD_MSS_OPTION</a>(mss)</td></tr>
<tr class="separator:abdc99c343efc6c81abf60bb62b361dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51de4ded7d342456d31722493c92c969" id="r_a51de4ded7d342456d31722493c92c969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51de4ded7d342456d31722493c92c969">tcp_init</a> (void)</td></tr>
<tr class="separator:a51de4ded7d342456d31722493c92c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3846a756b13214ed88ea47d0ff8279eb" id="r_a3846a756b13214ed88ea47d0ff8279eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr</a> (void)</td></tr>
<tr class="separator:a3846a756b13214ed88ea47d0ff8279eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421fb42ef919018e14ae413adfee9905" id="r_a421fb42ef919018e14ae413adfee9905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr</a> (void)</td></tr>
<tr class="separator:a421fb42ef919018e14ae413adfee9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf446b07e52161b8a53cea07bc6c366d" id="r_abf446b07e52161b8a53cea07bc6c366d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf446b07e52161b8a53cea07bc6c366d">tcp_fasttmr</a> (void)</td></tr>
<tr class="separator:abf446b07e52161b8a53cea07bc6c366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae0268e59fda0665fdd08c6e77ec547" id="r_a5ae0268e59fda0665fdd08c6e77ec547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae0268e59fda0665fdd08c6e77ec547">tcp_txnow</a> (void)</td></tr>
<tr class="separator:a5ae0268e59fda0665fdd08c6e77ec547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70c3c99d9dd6b07f7e11f7ba5eedcb5" id="r_ae70c3c99d9dd6b07f7e11f7ba5eedcb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, struct <a class="el" href="structnetif.html">netif</a> *inp)</td></tr>
<tr class="separator:ae70c3c99d9dd6b07f7e11f7ba5eedcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4cb4f0391916cea723b5b5a11df2bb" id="r_a9a4cb4f0391916cea723b5b5a11df2bb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a4cb4f0391916cea723b5b5a11df2bb">tcp_alloc</a> (u8_t prio)</td></tr>
<tr class="separator:a9a4cb4f0391916cea723b5b5a11df2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b6b075c27c64dfb8c402ac961fb910" id="r_aa2b6b075c27c64dfb8c402ac961fb910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2b6b075c27c64dfb8c402ac961fb910">tcp_free</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aa2b6b075c27c64dfb8c402ac961fb910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f0f1ca01dbccd680eaa2d8433cd7fe" id="r_ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f0f1ca01dbccd680eaa2d8433cd7fe">tcp_abandon</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int reset)</td></tr>
<tr class="separator:ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefde3e34b2cc8df9654986484c44a996" id="r_aefde3e34b2cc8df9654986484c44a996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aefde3e34b2cc8df9654986484c44a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75fefe4fe509845be156d6e424eb6f1" id="r_af75fefe4fe509845be156d6e424eb6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af75fefe4fe509845be156d6e424eb6f1">tcp_rexmit</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:af75fefe4fe509845be156d6e424eb6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f318930bd6d49074343cc79c5166f39" id="r_a1f318930bd6d49074343cc79c5166f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f318930bd6d49074343cc79c5166f39">tcp_rexmit_rto_prepare</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a1f318930bd6d49074343cc79c5166f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef9dc094e21bdf0779aed25ab0b08d4" id="r_a9ef9dc094e21bdf0779aed25ab0b08d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef9dc094e21bdf0779aed25ab0b08d4">tcp_rexmit_rto_commit</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a9ef9dc094e21bdf0779aed25ab0b08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ef9c8ab4629eb721987ae316b9f30f" id="r_ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5ef9c8ab4629eb721987ae316b9f30f">tcp_rexmit_rto</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ee7b4d59f125cc8bfac3bb5ca3937" id="r_adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb6ee7b4d59f125cc8bfac3bb5ca3937">tcp_rexmit_fast</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c254b779db4e517cb34e41301588d" id="r_a6d2c254b779db4e517cb34e41301588d"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d2c254b779db4e517cb34e41301588d">tcp_update_rcv_ann_wnd</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6d2c254b779db4e517cb34e41301588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0075b56ad4b0eca7c9d439cf150e1973" id="r_a0075b56ad4b0eca7c9d439cf150e1973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0075b56ad4b0eca7c9d439cf150e1973">tcp_process_refused_data</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0075b56ad4b0eca7c9d439cf150e1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc672b9d14a65e61040707c45302ba" id="r_a44fc672b9d14a65e61040707c45302ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fc672b9d14a65e61040707c45302ba">tcp_pcb_purge</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a44fc672b9d14a65e61040707c45302ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaef096f6a03bf5b778329bb66ee06f6" id="r_aaaef096f6a03bf5b778329bb66ee06f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaef096f6a03bf5b778329bb66ee06f6">tcp_pcb_remove</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aaaef096f6a03bf5b778329bb66ee06f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9bb9809769197bce9b2499d55cf28c" id="r_a3d9bb9809769197bce9b2499d55cf28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9bb9809769197bce9b2499d55cf28c">tcp_segs_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a3d9bb9809769197bce9b2499d55cf28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6283651b26f74dba2444159aee88b20" id="r_ac6283651b26f74dba2444159aee88b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6283651b26f74dba2444159aee88b20">tcp_seg_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:ac6283651b26f74dba2444159aee88b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9384b436de95d5bf8550438b9d3c8cd4" id="r_a9384b436de95d5bf8550438b9d3c8cd4"><td class="memItemLeft" align="right" valign="top">struct tcp_seg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9384b436de95d5bf8550438b9d3c8cd4">tcp_seg_copy</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a9384b436de95d5bf8550438b9d3c8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ba9d645a8910436c3d7cf13dba342" id="r_af40ba9d645a8910436c3d7cf13dba342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af40ba9d645a8910436c3d7cf13dba342">tcp_send_fin</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:af40ba9d645a8910436c3d7cf13dba342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5d552647d567095876aab202bfd1a" id="r_aa7d5d552647d567095876aab202bfd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7d5d552647d567095876aab202bfd1a">tcp_enqueue_flags</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t flags)</td></tr>
<tr class="separator:aa7d5d552647d567095876aab202bfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f8051c9633d3017c588245cdc4014" id="r_aa90f8051c9633d3017c588245cdc4014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa90f8051c9633d3017c588245cdc4014">tcp_rst</a> (const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u32_t seqno, u32_t ackno, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *local_ip, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *remote_ip, u16_t local_port, u16_t remote_port)</td></tr>
<tr class="separator:aa90f8051c9633d3017c588245cdc4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf7cbc5aa473de8116dc9f00cbc5d57" id="r_a7cf7cbc5aa473de8116dc9f00cbc5d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf7cbc5aa473de8116dc9f00cbc5d57">tcp_rst_netif</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, u32_t seqno, u32_t ackno, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *local_ip, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *remote_ip, u16_t local_port, u16_t remote_port)</td></tr>
<tr class="separator:a7cf7cbc5aa473de8116dc9f00cbc5d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5dc2fa74855a84b2da642ba31059ea" id="r_afd5dc2fa74855a84b2da642ba31059ea"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd5dc2fa74855a84b2da642ba31059ea">tcp_next_iss</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:afd5dc2fa74855a84b2da642ba31059ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8bb5fc8522515aa35d305774cc5332" id="r_a0d8bb5fc8522515aa35d305774cc5332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d8bb5fc8522515aa35d305774cc5332">tcp_keepalive</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0d8bb5fc8522515aa35d305774cc5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac930859c4e4ad9fcf6bb25ef5e91bcd5" id="r_ac930859c4e4ad9fcf6bb25ef5e91bcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac930859c4e4ad9fcf6bb25ef5e91bcd5">tcp_split_unsent_seg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t split)</td></tr>
<tr class="separator:ac930859c4e4ad9fcf6bb25ef5e91bcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20490aa45c771c38ce8ad3031cbdf6" id="r_a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c20490aa45c771c38ce8ad3031cbdf6">tcp_zero_window_probe</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3b5396c40f32dd8b21e7d63b3e1b3" id="r_a08a3b5396c40f32dd8b21e7d63b3e1b3"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a3b5396c40f32dd8b21e7d63b3e1b3">tcp_eff_send_mss_netif</a> (u16_t sendmss, struct <a class="el" href="structnetif.html">netif</a> *outif, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *dest)</td></tr>
<tr class="separator:a08a3b5396c40f32dd8b21e7d63b3e1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3f604fc8d20870d8cab291da5701c" id="r_a0cb3f604fc8d20870d8cab291da5701c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb3f604fc8d20870d8cab291da5701c">tcp_recv_null</a> (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a0cb3f604fc8d20870d8cab291da5701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8181bc316fdf61b85f787c5cadfcd249" id="r_a8181bc316fdf61b85f787c5cadfcd249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8181bc316fdf61b85f787c5cadfcd249">tcp_timer_needed</a> (void)</td></tr>
<tr class="separator:a8181bc316fdf61b85f787c5cadfcd249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c2d1ad02134c79fc72fe95ee2a703" id="r_a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d0c2d1ad02134c79fc72fe95ee2a703">tcp_netif_ip_addr_changed</a> (const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *old_addr, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *new_addr)</td></tr>
<tr class="separator:a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5265b1df024d04287ed3edc02b1b9ccc" id="r_a5265b1df024d04287ed3edc02b1b9ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5265b1df024d04287ed3edc02b1b9ccc">tcp_ext_arg_invoke_callbacks_passive_open</a> (struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *cpcb)</td></tr>
<tr class="separator:a5265b1df024d04287ed3edc02b1b9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1b42a7ac0fc173a42d575f86853d32a8" id="r_a1b42a7ac0fc173a42d575f86853d32a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></td></tr>
<tr class="separator:a1b42a7ac0fc173a42d575f86853d32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe1350e510d4308ac9969ffb4c9c81" id="r_a96fe1350e510d4308ac9969ffb4c9c81"><td class="memItemLeft" align="right" valign="top">union tcp_listen_pcbs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></td></tr>
<tr class="separator:a96fe1350e510d4308ac9969ffb4c9c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c09dbae67ccc06b659d9f1a388f911" id="r_a78c09dbae67ccc06b659d9f1a388f911"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></td></tr>
<tr class="separator:a78c09dbae67ccc06b659d9f1a388f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a522a66c5e1f1a4e28fe7a672cc64e3" id="r_a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></td></tr>
<tr class="separator:a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e1079ab223e1cb27208c45e3c84df7" id="r_af5e1079ab223e1cb27208c45e3c84df7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e1079ab223e1cb27208c45e3c84df7">tcp_pcb_lists</a> [4]</td></tr>
<tr class="separator:af5e1079ab223e1cb27208c45e3c84df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TCP internal implementations (do not use in application code) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abdc99c343efc6c81abf60bb62b361dd8" name="abdc99c343efc6c81abf60bb62b361dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc99c343efc6c81abf60bb62b361dd8">&#9670;&#160;</a></span>TCP_BUILD_MSS_OPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_BUILD_MSS_OPTION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mss</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_function" href="def_8c.html#a14f94347a5b9b9e3602705b75b7ae524">lwip_htonl</a>(0x02040000 | ((mss) &amp; 0xFFFF))</div>
<div class="ttc" id="adef_8c_html_a14f94347a5b9b9e3602705b75b7ae524"><div class="ttname"><a href="def_8c.html#a14f94347a5b9b9e3602705b75b7ae524">lwip_htonl</a></div><div class="ttdeci">u32_t lwip_htonl(u32_t n)</div><div class="ttdef"><b>Definition</b> def.c:90</div></div>
</div><!-- fragment --><p>This returns a TCP header option for MSS in an u32_t </p>

</div>
</div>
<a id="aea0c47b916a8a25f82d2063335033aee" name="aea0c47b916a8a25f82d2063335033aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0c47b916a8a25f82d2063335033aee">&#9670;&#160;</a></span>TCP_CHECKSUM_ON_COPY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_CHECKSUM_ON_COPY&#160;&#160;&#160;(<a class="el" href="group__lwip__opts__checksum.html#ga9f60183f0442bdbeefd6b395c6647613">LWIP_CHECKSUM_ON_COPY</a> &amp;&amp; <a class="el" href="group__lwip__opts__checksum.html#ga800069963cc4552b99235237c22f00bb">CHECKSUM_GEN_TCP</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't generate checksum on copy if CHECKSUM_GEN_TCP is disabled </p>

</div>
</div>
<a id="afbd7a2997e3a3b7569efc3298e2e409f" name="afbd7a2997e3a3b7569efc3298e2e409f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd7a2997e3a3b7569efc3298e2e409f">&#9670;&#160;</a></span>tcp_do_output_nagle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_do_output_nagle</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tpcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                            ((((tpcb)-&gt;unacked == NULL) || \</div>
<div class="line">                            ((tpcb)-&gt;flags &amp; (TF_NODELAY | TF_INFR)) || \</div>
<div class="line">                            (((tpcb)-&gt;unsent != NULL) &amp;&amp; (((tpcb)-&gt;unsent-&gt;next != NULL) || \</div>
<div class="line">                              ((tpcb)-&gt;unsent-&gt;len &gt;= (tpcb)-&gt;mss))) || \</div>
<div class="line">                            ((tcp_sndbuf(tpcb) == 0) || (tcp_sndqueuelen(tpcb) &gt;= <a class="code hl_define" href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>)) \</div>
<div class="line">                            ) ? 1 : 0)</div>
<div class="ttc" id="agroup__lwip__opts__tcp_html_ga9beaa47832ead4180981bfbf71074904"><div class="ttname"><a href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a></div><div class="ttdeci">#define TCP_SND_QUEUELEN</div><div class="ttdef"><b>Definition</b> opt.h:1373</div></div>
</div><!-- fragment --><p>This is the Nagle algorithm: try to combine user data to send as few TCP segments as possible. Only send if</p><ul>
<li>no previously transmitted data on the connection remains unacknowledged or</li>
<li>the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or</li>
<li>the only unsent segment is at least pcb-&gt;mss bytes long (or there is more than one unsent segment - with lwIP, this can happen although unsent-&gt;len &lt; mss)</li>
<li>or if we are in fast-retransmit (TF_INFR) </li>
</ul>

</div>
</div>
<a id="a178a6e9966d03c3326b9e0568666bb69" name="a178a6e9966d03c3326b9e0568666bb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a6e9966d03c3326b9e0568666bb69">&#9670;&#160;</a></span>TCP_OVERSIZE_DBGCHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OVERSIZE_DBGCHECK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabled extra-check for TCP_OVERSIZE if LWIP_DEBUG is enabled </p>

</div>
</div>
<a id="ac9dbdaeac3e25f5badf3a763a1b0b990" name="ac9dbdaeac3e25f5badf3a763a1b0b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dbdaeac3e25f5badf3a763a1b0b990">&#9670;&#160;</a></span>TF_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TF_RESET&#160;&#160;&#160;(u8_t)0x08U   /* Connection was reset. */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used on input processing, not on pcb-&gt;flags </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4f0f1ca01dbccd680eaa2d8433cd7fe" name="ae4f0f1ca01dbccd680eaa2d8433cd7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f0f1ca01dbccd680eaa2d8433cd7fe">&#9670;&#160;</a></span>tcp_abandon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abandon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>reset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abandons a connection and optionally sends a RST to the remote host. Deletes the local protocol control block. This is done when a connection is killed because of shortage of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to abort </td></tr>
    <tr><td class="paramname">reset</td><td>boolean to indicate whether a reset should be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a4cb4f0391916cea723b5b5a11df2bb" name="a9a4cb4f0391916cea723b5b5a11df2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4cb4f0391916cea723b5b5a11df2bb">&#9670;&#160;</a></span>tcp_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> * tcp_alloc </td>
          <td>(</td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>prio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>priority for the new pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

</div>
</div>
<a id="a08a3b5396c40f32dd8b21e7d63b3e1b3" name="a08a3b5396c40f32dd8b21e7d63b3e1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a3b5396c40f32dd8b21e7d63b3e1b3">&#9670;&#160;</a></span>tcp_eff_send_mss_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t tcp_eff_send_mss_netif </td>
          <td>(</td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>sendmss</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>outif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the effective send mss that can be used for a specific IP address by calculating the minimum of TCP_MSS and the mtu (if set) of the target netif (if not NULL). </p>

</div>
</div>
<a id="aa7d5d552647d567095876aab202bfd1a" name="aa7d5d552647d567095876aab202bfd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d5d552647d567095876aab202bfd1a">&#9670;&#160;</a></span>tcp_enqueue_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_enqueue_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue SYN or FIN for transmission.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a>, tcp_listen_input, and <a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (via <a class="el" href="tcp__out_8c.html#af40ba9d645a8910436c3d7cf13dba342">tcp_send_fin</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection. </td></tr>
    <tr><td class="paramname">flags</td><td>TCP header flags to set in the outgoing segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5265b1df024d04287ed3edc02b1b9ccc" name="a5265b1df024d04287ed3edc02b1b9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5265b1df024d04287ed3edc02b1b9ccc">&#9670;&#160;</a></span>tcp_ext_arg_invoke_callbacks_passive_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_ext_arg_invoke_callbacks_passive_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *</td>          <td class="paramname"><span class="paramname"><em>lpcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>cpcb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calls the "passive_open" callback for all ext_args if a connection is in the process of being accepted. This is called just after the SYN is received and before a SYN/ACK is sent, to allow to modify the very first segment sent even on passive open. Naturally, the "accepted" callback of the pcb has not been called yet! </p>

</div>
</div>
<a id="abf446b07e52161b8a53cea07bc6c366d" name="abf446b07e52161b8a53cea07bc6c366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf446b07e52161b8a53cea07bc6c366d">&#9670;&#160;</a></span>tcp_fasttmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_fasttmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data previously "refused" by upper layer (application) and sends delayed ACKs or pending FINs.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a id="aa2b6b075c27c64dfb8c402ac961fb910" name="aa2b6b075c27c64dfb8c402ac961fb910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b6b075c27c64dfb8c402ac961fb910">&#9670;&#160;</a></span>tcp_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a tcp pcb </p>

</div>
</div>
<a id="a51de4ded7d342456d31722493c92c969" name="a51de4ded7d342456d31722493c92c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de4ded7d342456d31722493c92c969">&#9670;&#160;</a></span>tcp_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize this module. </p>

</div>
</div>
<a id="ae70c3c99d9dd6b07f7e11f7ba5eedcb5" name="ae70c3c99d9dd6b07f7e11f7ba5eedcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">&#9670;&#160;</a></span>tcp_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_input </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>inp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The initial input processing of TCP. It verifies the TCP header, demultiplexes the segment between the PCBs and passes it on to tcp_process(), which implements the TCP finite state machine. This function is called by the IP layer (in <a class="el" href="group__lwip__nosys.html#ga3c420dab0c6760df099a2d688fa42a26">ip_input()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>received TCP segment to process (p-&gt;payload pointing to the TCP header) </td></tr>
    <tr><td class="paramname">inp</td><td>network interface on which this segment was received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d8bb5fc8522515aa35d305774cc5332" name="a0d8bb5fc8522515aa35d305774cc5332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8bb5fc8522515aa35d305774cc5332">&#9670;&#160;</a></span>tcp_keepalive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_keepalive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send keepalive packets to keep a connection active although no data is sent over it.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a keepalive packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d0c2d1ad02134c79fc72fe95ee2a703" name="a4d0c2d1ad02134c79fc72fe95ee2a703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0c2d1ad02134c79fc72fe95ee2a703">&#9670;&#160;</a></span>tcp_netif_ip_addr_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_netif_ip_addr_changed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>old_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>new_addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called from <a class="el" href="netif_8c.html">netif.c</a> when address is changed or netif is removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_addr</td><td>IP address of the netif before change </td></tr>
    <tr><td class="paramname">new_addr</td><td>IP address of the netif after change or NULL if netif has been removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd5dc2fa74855a84b2da642ba31059ea" name="afd5dc2fa74855a84b2da642ba31059ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5dc2fa74855a84b2da642ba31059ea">&#9670;&#160;</a></span>tcp_next_iss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_next_iss </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a new initial sequence number for new connections.</p>
<dl class="section return"><dt>Returns</dt><dd>u32_t pseudo random sequence number </dd></dl>

</div>
</div>
<a id="a44fc672b9d14a65e61040707c45302ba" name="a44fc672b9d14a65e61040707c45302ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc672b9d14a65e61040707c45302ba">&#9670;&#160;</a></span>tcp_pcb_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges a TCP PCB. Removes any buffered data and frees the buffer memory (pcb-&gt;ooseq, pcb-&gt;unsent and pcb-&gt;unacked are freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is not deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaef096f6a03bf5b778329bb66ee06f6" name="aaaef096f6a03bf5b778329bb66ee06f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaef096f6a03bf5b778329bb66ee06f6">&#9670;&#160;</a></span>tcp_pcb_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **</td>          <td class="paramname"><span class="paramname"><em>pcblist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcblist</td><td>PCB list to purge. </td></tr>
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is NOT deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0075b56ad4b0eca7c9d439cf150e1973" name="a0075b56ad4b0eca7c9d439cf150e1973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0075b56ad4b0eca7c9d439cf150e1973">&#9670;&#160;</a></span>tcp_process_refused_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_process_refused_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass pcb-&gt;refused_data to the recv callback </p>

</div>
</div>
<a id="a0cb3f604fc8d20870d8cab291da5701c" name="a0cb3f604fc8d20870d8cab291da5701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb3f604fc8d20870d8cab291da5701c">&#9670;&#160;</a></span>tcp_recv_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_recv_null </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default receive callback that is called if the user didn't register a recv callback for the pcb. </p>

</div>
</div>
<a id="af75fefe4fe509845be156d6e424eb6f1" name="af75fefe4fe509845be156d6e424eb6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75fefe4fe509845be156d6e424eb6f1">&#9670;&#160;</a></span>tcp_rexmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_rexmit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue the first unacked segment for retransmission</p>
<p>Called by tcp_receive() for fast retransmit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6ee7b4d59f125cc8bfac3bb5ca3937" name="adb6ee7b4d59f125cc8bfac3bb5ca3937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6ee7b4d59f125cc8bfac3bb5ca3937">&#9670;&#160;</a></span>tcp_rexmit_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_fast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle retransmission after three dupacks received</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5ef9c8ab4629eb721987ae316b9f30f" name="ab5ef9c8ab4629eb721987ae316b9f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ef9c8ab4629eb721987ae316b9f30f">&#9670;&#160;</a></span>tcp_rexmit_rto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_rto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by tcp_process() only, <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> needs to do some things between "prepare" and "commit".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef9dc094e21bdf0779aed25ab0b08d4" name="a9ef9dc094e21bdf0779aed25ab0b08d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef9dc094e21bdf0779aed25ab0b08d4">&#9670;&#160;</a></span>tcp_rexmit_rto_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_rto_commit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> for slow retransmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f318930bd6d49074343cc79c5166f39" name="a1f318930bd6d49074343cc79c5166f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f318930bd6d49074343cc79c5166f39">&#9670;&#160;</a></span>tcp_rexmit_rto_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_rexmit_rto_prepare </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> for slow retransmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa90f8051c9633d3017c588245cdc4014" name="aa90f8051c9633d3017c588245cdc4014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90f8051c9633d3017c588245cdc4014">&#9670;&#160;</a></span>tcp_rst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rst </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t</td>          <td class="paramname"><span class="paramname"><em>seqno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t</td>          <td class="paramname"><span class="paramname"><em>ackno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>local_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>local_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>remote_port</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a TCP RESET packet (empty segment with RST flag set) to abort a connection.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort()</a> (to abort a local connection), tcp_closen() (if not all data has been received by the application), tcp_timewait_input() (if a SYN is received) and tcp_process() (received segment in the wrong state).</p>
<p>Since a RST segment is in most cases not sent for an active connection, <a class="el" href="tcp__out_8c.html#aa90f8051c9633d3017c588245cdc4014">tcp_rst()</a> has a number of arguments that are taken from a <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for most other segment output functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>TCP pcb (may be NULL if no pcb is available) </td></tr>
    <tr><td class="paramname">seqno</td><td>the sequence number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">ackno</td><td>the acknowledge number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">local_ip</td><td>the local IP address to send the segment from </td></tr>
    <tr><td class="paramname">remote_ip</td><td>the remote IP address to send the segment to </td></tr>
    <tr><td class="paramname">local_port</td><td>the local TCP port to send the segment from </td></tr>
    <tr><td class="paramname">remote_port</td><td>the remote TCP port to send the segment to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf7cbc5aa473de8116dc9f00cbc5d57" name="a7cf7cbc5aa473de8116dc9f00cbc5d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf7cbc5aa473de8116dc9f00cbc5d57">&#9670;&#160;</a></span>tcp_rst_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rst_netif </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t</td>          <td class="paramname"><span class="paramname"><em>seqno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t</td>          <td class="paramname"><span class="paramname"><em>ackno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>local_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>local_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>remote_port</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a TCP RESET packet (empty segment with RST flag set) to show that there is no matching local connection for a received segment.</p>
<p>Called by <a class="el" href="tcp__in_8c.html#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input()</a> (if no matching local pcb was found) and tcp_listen_input() (if incoming segment has ACK flag set).</p>
<p>Since a RST segment is in most cases not sent for an active connection, <a class="el" href="tcp__out_8c.html#aa90f8051c9633d3017c588245cdc4014">tcp_rst()</a> has a number of arguments that are taken from a <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for most other segment output functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>the netif on which to send the RST (since we have no pcb) </td></tr>
    <tr><td class="paramname">seqno</td><td>the sequence number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">ackno</td><td>the acknowledge number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">local_ip</td><td>the local IP address to send the segment from </td></tr>
    <tr><td class="paramname">remote_ip</td><td>the remote IP address to send the segment to </td></tr>
    <tr><td class="paramname">local_port</td><td>the local TCP port to send the segment from </td></tr>
    <tr><td class="paramname">remote_port</td><td>the remote TCP port to send the segment to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9384b436de95d5bf8550438b9d3c8cd4" name="a9384b436de95d5bf8550438b9d3c8cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9384b436de95d5bf8550438b9d3c8cd4">&#9670;&#160;</a></span>tcp_seg_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct tcp_seg * tcp_seg_copy </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the given TCP segment. The pbuf and data are not copied, only the pointers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>the old tcp_seg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of seg </dd></dl>

</div>
</div>
<a id="ac6283651b26f74dba2444159aee88b20" name="ac6283651b26f74dba2444159aee88b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6283651b26f74dba2444159aee88b20">&#9670;&#160;</a></span>tcp_seg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_seg_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a TCP segment (tcp_seg structure).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>single tcp_seg to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d9bb9809769197bce9b2499d55cf28c" name="a3d9bb9809769197bce9b2499d55cf28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9bb9809769197bce9b2499d55cf28c">&#9670;&#160;</a></span>tcp_segs_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_segs_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates a list of TCP segments (tcp_seg structures).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>tcp_seg list of TCP segments to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefde3e34b2cc8df9654986484c44a996" name="aefde3e34b2cc8df9654986484c44a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefde3e34b2cc8df9654986484c44a996">&#9670;&#160;</a></span>tcp_send_empty_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_empty_ack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an ACK without data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to send the ACK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af40ba9d645a8910436c3d7cf13dba342" name="af40ba9d645a8910436c3d7cf13dba342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ba9d645a8910436c3d7cf13dba342">&#9670;&#160;</a></span>tcp_send_fin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_fin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by <a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close()</a> to send a segment including FIN flag but not data. This FIN may be added to an existing segment or a new, otherwise empty segment is enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> over which to send a segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if sent, another err_t otherwise </dd></dl>

</div>
</div>
<a id="a421fb42ef919018e14ae413adfee9905" name="a421fb42ef919018e14ae413adfee9905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421fb42ef919018e14ae413adfee9905">&#9670;&#160;</a></span>tcp_slowtmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_slowtmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called every 500 ms and implements the retransmission timer and the timer that removes PCBs that have been in TIME-WAIT for enough time. It also increments various timers such as the inactivity timer in each PCB.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a id="ac930859c4e4ad9fcf6bb25ef5e91bcd5" name="ac930859c4e4ad9fcf6bb25ef5e91bcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac930859c4e4ad9fcf6bb25ef5e91bcd5">&#9670;&#160;</a></span>tcp_split_unsent_seg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_split_unsent_seg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>split</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split segment on the head of the unsent queue. If return is not ERR_OK, existing head remains intact</p>
<p>The split is accomplished by creating a new TCP segment and pbuf which holds the remainder payload after the split. The original pbuf is trimmed to new length. This allows splitting of read-only pbufs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to split the unsent head </td></tr>
    <tr><td class="paramname">split</td><td>the amount of payload to remain in the head </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8181bc316fdf61b85f787c5cadfcd249" name="a8181bc316fdf61b85f787c5cadfcd249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8181bc316fdf61b85f787c5cadfcd249">&#9670;&#160;</a></span>tcp_timer_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_timer_needed </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External function (implemented in timers.c), called when TCP detects that a timer is needed (i.e. active- or time-wait-pcb found).</p>
<p>Called from TCP_REG when registering a new PCB: the reason is to have the TCP timer only running when there are active (or time-wait) PCBs. </p>

</div>
</div>
<a id="a3846a756b13214ed88ea47d0ff8279eb" name="a3846a756b13214ed88ea47d0ff8279eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3846a756b13214ed88ea47d0ff8279eb">&#9670;&#160;</a></span>tcp_tmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_tmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called periodically to dispatch TCP timers. </p>

</div>
</div>
<a id="a5ae0268e59fda0665fdd08c6e77ec547" name="a5ae0268e59fda0665fdd08c6e77ec547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae0268e59fda0665fdd08c6e77ec547">&#9670;&#160;</a></span>tcp_txnow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_txnow </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set </p>

</div>
</div>
<a id="a6d2c254b779db4e517cb34e41301588d" name="a6d2c254b779db4e517cb34e41301588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2c254b779db4e517cb34e41301588d">&#9670;&#160;</a></span>tcp_update_rcv_ann_wnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_update_rcv_ann_wnd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the state that tracks the available window space to advertise.</p>
<p>Returns how much extra window would be advertised if we sent an update now. </p>

</div>
</div>
<a id="a6c20490aa45c771c38ce8ad3031cbdf6" name="a6c20490aa45c771c38ce8ad3031cbdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c20490aa45c771c38ce8ad3031cbdf6">&#9670;&#160;</a></span>tcp_zero_window_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_zero_window_probe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send persist timer zero-window probes to keep a connection active when a window update is lost.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a zero-window probe packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a78c09dbae67ccc06b659d9f1a388f911" name="a78c09dbae67ccc06b659d9f1a388f911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c09dbae67ccc06b659d9f1a388f911">&#9670;&#160;</a></span>tcp_active_pcbs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_active_pcbs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of all TCP PCBs that are in a state in which they accept or send data. </p>

</div>
</div>
<a id="a1b42a7ac0fc173a42d575f86853d32a8" name="a1b42a7ac0fc173a42d575f86853d32a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b42a7ac0fc173a42d575f86853d32a8">&#9670;&#160;</a></span>tcp_bound_pcbs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_bound_pcbs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of all TCP PCBs bound but not yet (connected || listening) </p>

</div>
</div>
<a id="a96fe1350e510d4308ac9969ffb4c9c81" name="a96fe1350e510d4308ac9969ffb4c9c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fe1350e510d4308ac9969ffb4c9c81">&#9670;&#160;</a></span>tcp_listen_pcbs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">union tcp_listen_pcbs_t tcp_listen_pcbs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of all TCP PCBs in LISTEN state </p>

</div>
</div>
<a id="af5e1079ab223e1cb27208c45e3c84df7" name="af5e1079ab223e1cb27208c45e3c84df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e1079ab223e1cb27208c45e3c84df7">&#9670;&#160;</a></span>tcp_pcb_lists</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>** const tcp_pcb_lists[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An array with all (non-temporary) PCB lists, mainly used for smaller code size </p>

</div>
</div>
<a id="a9a522a66c5e1f1a4e28fe7a672cc64e3" name="a9a522a66c5e1f1a4e28fe7a672cc64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">&#9670;&#160;</a></span>tcp_tw_pcbs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_tw_pcbs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of all TCP PCBs in TIME-WAIT state </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_4e6b3cf33a61b6caac9c8ac30c866f37.html">lwip</a></li><li class="navelem"><a class="el" href="dir_460c501b2432fc107adcb38111835e48.html">priv</a></li><li class="navelem"><a class="el" href="tcp__priv_8h.html">tcp_priv.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
