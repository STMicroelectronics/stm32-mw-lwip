<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: src/include/lwip/tcp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">lwIP<span id="projectnumber">&#160;2.2.0</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tcp_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tcp.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcpbase_8h.html">lwip/tcpbase.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem_8h.html">lwip/mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pbuf_8h.html">lwip/pbuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip_8h.html">lwip/ip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="icmp_8h.html">lwip/icmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="err_8h.html">lwip/err.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6_8h.html">lwip/ip6.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6__addr_8h.html">lwip/ip6_addr.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__ext__arg__callbacks.html">tcp_ext_arg_callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__pcb.html">tcp_pcb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a874630045102fc5f1442704a790c8bb8" id="r_a874630045102fc5f1442704a790c8bb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a874630045102fc5f1442704a790c8bb8">TCP_PCB_COMMON</a>(type)</td></tr>
<tr class="separator:a874630045102fc5f1442704a790c8bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a00517abce6856d6c82f0efebdafb734d" id="r_a00517abce6856d6c82f0efebdafb734d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a>) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a00517abce6856d6c82f0efebdafb734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780cfac08b02c66948ab94ea974202e8" id="r_a780cfac08b02c66948ab94ea974202e8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a>) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a780cfac08b02c66948ab94ea974202e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60622ffaa099e97f66fb56e437fca18" id="r_aa60622ffaa099e97f66fb56e437fca18"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a>) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, u16_t len)</td></tr>
<tr class="separator:aa60622ffaa099e97f66fb56e437fca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66deb97618a9cd9d57fca28c5245e073" id="r_a66deb97618a9cd9d57fca28c5245e073"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a>) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb)</td></tr>
<tr class="separator:a66deb97618a9cd9d57fca28c5245e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f9e3551e575c0ef06d6daa7f06e55" id="r_a1b4f9e3551e575c0ef06d6daa7f06e55"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a>) (void *arg, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a1b4f9e3551e575c0ef06d6daa7f06e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939867106bd492caf2d85852fb7f6ae8" id="r_a939867106bd492caf2d85852fb7f6ae8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a>) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a939867106bd492caf2d85852fb7f6ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20881e537f5be7847d88fe2a0c8fd2cd" id="r_a20881e537f5be7847d88fe2a0c8fd2cd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20881e537f5be7847d88fe2a0c8fd2cd">tcp_extarg_callback_pcb_destroyed_fn</a>) (u8_t id, void *data)</td></tr>
<tr class="separator:a20881e537f5be7847d88fe2a0c8fd2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba649c5bdf19d47e39643392b6d88588" id="r_aba649c5bdf19d47e39643392b6d88588"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba649c5bdf19d47e39643392b6d88588">tcp_extarg_callback_passive_open_fn</a>) (u8_t id, struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *cpcb)</td></tr>
<tr class="separator:aba649c5bdf19d47e39643392b6d88588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2e00c668b99d92113cd595647702be83" id="r_ga2e00c668b99d92113cd595647702be83"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga2e00c668b99d92113cd595647702be83">tcp_new</a> (void)</td></tr>
<tr class="separator:ga2e00c668b99d92113cd595647702be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f6955b7248c76a073cd1be461aeb5b" id="r_ga89f6955b7248c76a073cd1be461aeb5b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga89f6955b7248c76a073cd1be461aeb5b">tcp_new_ip_type</a> (u8_t type)</td></tr>
<tr class="separator:ga89f6955b7248c76a073cd1be461aeb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10926e6f76f73e17c0d37aaab3e56b6" id="r_gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void *arg)</td></tr>
<tr class="separator:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afd0b316a87a5eeff4726dc95006ed0" id="r_ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8afd0b316a87a5eeff4726dc95006ed0">tcp_recv</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a> recv)</td></tr>
<tr class="separator:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1596332b93bb6249179f3b89f24bd808" id="r_ga1596332b93bb6249179f3b89f24bd808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga1596332b93bb6249179f3b89f24bd808">tcp_sent</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a> sent)</td></tr>
<tr class="separator:ga1596332b93bb6249179f3b89f24bd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1346c4e34d3bc7c01e1b47142ab3121" id="r_gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a> err)</td></tr>
<tr class="separator:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4c3e380fc60c8fb9b3aa95eda94c62" id="r_gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a> accept)</td></tr>
<tr class="separator:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba47015098ed7ce523dcf7bdf70f7e5" id="r_gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a> poll, u8_t interval)</td></tr>
<tr class="separator:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427b11c7b98c748ec487cd43093bd2f8" id="r_ga427b11c7b98c748ec487cd43093bd2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619154658137a23839ca3b94882131ca" id="r_ga619154658137a23839ca3b94882131ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga619154658137a23839ca3b94882131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac0856a52b5789dc897d4c7137ec44" id="r_gabdac0856a52b5789dc897d4c7137ec44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len)</td></tr>
<tr class="separator:gabdac0856a52b5789dc897d4c7137ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5aa67bd7fc66fef43f77a55a1201ee" id="r_gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6469a15709088e80024258dbe80fcd1f" id="r_ga6469a15709088e80024258dbe80fcd1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6469a15709088e80024258dbe80fcd1f">tcp_bind_netif</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga6469a15709088e80024258dbe80fcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a31deea4cadacd39f9485f37cfdd012" id="r_ga9a31deea4cadacd39f9485f37cfdd012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *ipaddr, u16_t port, <a class="el" href="#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a> connected)</td></tr>
<tr class="separator:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8883f9735809f1679d744bc48f1c674a" id="r_ga8883f9735809f1679d744bc48f1c674a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8883f9735809f1679d744bc48f1c674a">tcp_listen_with_backlog_and_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> *err)</td></tr>
<tr class="separator:ga8883f9735809f1679d744bc48f1c674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bb2ca7f053e73545d36b745f236d54" id="r_ga77bb2ca7f053e73545d36b745f236d54"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga77bb2ca7f053e73545d36b745f236d54">tcp_listen_with_backlog</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog)</td></tr>
<tr class="separator:ga77bb2ca7f053e73545d36b745f236d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468c2260ddb01582e966ddcf3c25ce61" id="r_ga468c2260ddb01582e966ddcf3c25ce61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87093e137fcc53ea82a134a3f5b33623" id="r_ga87093e137fcc53ea82a134a3f5b33623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga87093e137fcc53ea82a134a3f5b33623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b94d57f1891b9287f88525a2ac561dd" id="r_ga5b94d57f1891b9287f88525a2ac561dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b94d57f1891b9287f88525a2ac561dd">tcp_shutdown</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int shut_rx, int shut_tx)</td></tr>
<tr class="separator:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2aa0efbf10e254930332b7c89cd8c5" id="r_ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const void *dataptr, u16_t len, u8_t apiflags)</td></tr>
<tr class="separator:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4234f1e95b6bde0e84d4ea97ae95bc" id="r_ga2c4234f1e95b6bde0e84d4ea97ae95bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga2c4234f1e95b6bde0e84d4ea97ae95bc">tcp_setprio</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t prio)</td></tr>
<tr class="separator:ga2c4234f1e95b6bde0e84d4ea97ae95bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbcc6d628f644a530daf629fa3e5f7f" id="r_ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4836e0b4f66439493e106a50400d1616" id="r_ga4836e0b4f66439493e106a50400d1616"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#ga4836e0b4f66439493e106a50400d1616">tcp_ext_arg_alloc_id</a> (void)</td></tr>
<tr class="separator:ga4836e0b4f66439493e106a50400d1616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacea54ce1154e7ae8ef0199ff1c5bdc5" id="r_gaacea54ce1154e7ae8ef0199ff1c5bdc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#gaacea54ce1154e7ae8ef0199ff1c5bdc5">tcp_ext_arg_set_callbacks</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t id, const struct <a class="el" href="structtcp__ext__arg__callbacks.html">tcp_ext_arg_callbacks</a> *const callbacks)</td></tr>
<tr class="separator:gaacea54ce1154e7ae8ef0199ff1c5bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c2397b2d85b3a902584fb64cdb961e" id="r_gaf5c2397b2d85b3a902584fb64cdb961e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#gaf5c2397b2d85b3a902584fb64cdb961e">tcp_ext_arg_set</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t id, void *arg)</td></tr>
<tr class="separator:gaf5c2397b2d85b3a902584fb64cdb961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7499018469cd9c3dc6a15ad91c338e56" id="r_ga7499018469cd9c3dc6a15ad91c338e56"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#ga7499018469cd9c3dc6a15ad91c338e56">tcp_ext_arg_get</a> (const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t id)</td></tr>
<tr class="separator:ga7499018469cd9c3dc6a15ad91c338e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TCP API (to be used from TCPIP thread)<br  />
 See also <a class="el" href="group__tcp__raw.html">TCP</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a874630045102fc5f1442704a790c8bb8" name="a874630045102fc5f1442704a790c8bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874630045102fc5f1442704a790c8bb8">&#9670;&#160;</a></span>TCP_PCB_COMMON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_PCB_COMMON</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  type *next; <span class="comment">/* for the linked list */</span> \</div>
<div class="line">  <span class="keywordtype">void</span> *callback_arg; \</div>
<div class="line">  TCP_PCB_EXTARGS \</div>
<div class="line">  enum tcp_state state; <span class="comment">/* TCP state */</span> \</div>
<div class="line">  u8_t prio; \</div>
<div class="line">  <span class="comment">/* ports are in host byte order */</span> \</div>
<div class="line">  u16_t local_port</div>
</div><!-- fragment --><p>members common to struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> and struct tcp_listen_pcb </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a00517abce6856d6c82f0efebdafb734d" name="a00517abce6856d6c82f0efebdafb734d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00517abce6856d6c82f0efebdafb734d">&#9670;&#160;</a></span>tcp_accept_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_accept_fn) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp accept callback functions. Called when a new connection can be accepted on a listening pcb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpcb</td><td>The new connection pcb </td></tr>
    <tr><td class="paramname">err</td><td>An error code if there has been an error accepting. Only return ERR_ABRT if you have called tcp_abort from within the callback function! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a939867106bd492caf2d85852fb7f6ae8" name="a939867106bd492caf2d85852fb7f6ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939867106bd492caf2d85852fb7f6ae8">&#9670;&#160;</a></span>tcp_connected_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_connected_fn) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp connected callback functions. Called when a pcb is connected to the remote side after initiating a connection attempt by calling <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpcb</td><td>The connection pcb which is connected </td></tr>
    <tr><td class="paramname">err</td><td>An unused error code, always ERR_OK currently ;-) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When a connection attempt fails, the error callback is currently called! </dd></dl>

</div>
</div>
<a id="a1b4f9e3551e575c0ef06d6daa7f06e55" name="a1b4f9e3551e575c0ef06d6daa7f06e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f9e3551e575c0ef06d6daa7f06e55">&#9670;&#160;</a></span>tcp_err_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tcp_err_fn) (void *arg, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp error callback functions. Called when the pcb receives a RST or is unexpectedly closed for any other reason.</p>
<dl class="section note"><dt>Note</dt><dd>The corresponding pcb is already freed when this callback is called!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code to indicate why the pcb has been closed ERR_ABRT: aborted through tcp_abort or by a TCP timer ERR_RST: the connection was reset by the remote host </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba649c5bdf19d47e39643392b6d88588" name="aba649c5bdf19d47e39643392b6d88588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba649c5bdf19d47e39643392b6d88588">&#9670;&#160;</a></span>tcp_extarg_callback_passive_open_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_extarg_callback_passive_open_fn) (u8_t id, struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *cpcb)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype to transition arguments from a listening pcb to an accepted pcb</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ext arg id (allocated via <a class="el" href="group__tcp__raw__extargs.html#ga4836e0b4f66439493e106a50400d1616">tcp_ext_arg_alloc_id</a>) </td></tr>
    <tr><td class="paramname">lpcb</td><td>the listening pcb accepting a connection </td></tr>
    <tr><td class="paramname">cpcb</td><td>the newly allocated connection pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if OK, any error if connection should be dropped </dd></dl>

</div>
</div>
<a id="a20881e537f5be7847d88fe2a0c8fd2cd" name="a20881e537f5be7847d88fe2a0c8fd2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20881e537f5be7847d88fe2a0c8fd2cd">&#9670;&#160;</a></span>tcp_extarg_callback_pcb_destroyed_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tcp_extarg_callback_pcb_destroyed_fn) (u8_t id, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for deallocation of arguments. Called <em>just before</em> the pcb is freed, so don't expect to be able to do anything with this pcb!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ext arg id (allocated via <a class="el" href="group__tcp__raw__extargs.html#ga4836e0b4f66439493e106a50400d1616">tcp_ext_arg_alloc_id</a>) </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the data (set via <a class="el" href="group__tcp__raw__extargs.html#gaf5c2397b2d85b3a902584fb64cdb961e">tcp_ext_arg_set</a> before) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66deb97618a9cd9d57fca28c5245e073" name="a66deb97618a9cd9d57fca28c5245e073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66deb97618a9cd9d57fca28c5245e073">&#9670;&#160;</a></span>tcp_poll_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_poll_fn) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp poll callback functions. Called periodically as specified by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpcb</td><td>tcp pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK: try to send some data by calling tcp_output Only return ERR_ABRT if you have called tcp_abort from within the callback function! </dd></dl>

</div>
</div>
<a id="a780cfac08b02c66948ab94ea974202e8" name="a780cfac08b02c66948ab94ea974202e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780cfac08b02c66948ab94ea974202e8">&#9670;&#160;</a></span>tcp_recv_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_recv_fn) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp receive callback functions. Called when data has been received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpcb</td><td>The connection pcb which received data </td></tr>
    <tr><td class="paramname">p</td><td>The received data (or NULL when the connection has been closed!) </td></tr>
    <tr><td class="paramname">err</td><td>An error code if there has been an error receiving Only return ERR_ABRT if you have called tcp_abort from within the callback function! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa60622ffaa099e97f66fb56e437fca18" name="aa60622ffaa099e97f66fb56e437fca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60622ffaa099e97f66fb56e437fca18">&#9670;&#160;</a></span>tcp_sent_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>(* tcp_sent_fn) (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, u16_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for tcp sent callback functions. Called when sent data has been acknowledged by the remote side. Use it to free corresponding resources. This also means that the pcb has now space available to send new data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Additional argument to pass to the callback function (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg()</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpcb</td><td>The connection pcb for which data has been acknowledged </td></tr>
    <tr><td class="paramname">len</td><td>The amount of bytes acknowledged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK: try to send some data by calling tcp_output Only return ERR_ABRT if you have called tcp_abort from within the callback function! </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_4e6b3cf33a61b6caac9c8ac30c866f37.html">lwip</a></li><li class="navelem"><a class="el" href="tcp_8h.html">tcp.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
