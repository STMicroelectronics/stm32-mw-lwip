<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: src/core/tcp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">lwIP<span id="projectnumber">&#160;2.1.3</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tcp_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">tcp.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="def_8h.html">lwip/def.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem_8h.html">lwip/mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memp_8h.html">lwip/memp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcp_8h.html">lwip/tcp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcp__priv_8h.html">lwip/priv/tcp_priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="debug_8h.html">lwip/debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stats_8h.html">lwip/stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6_8h.html">lwip/ip6.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6__addr_8h.html">lwip/ip6_addr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nd6_8h.html">lwip/nd6.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;path/to/my/lwip_hooks.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51de4ded7d342456d31722493c92c969" id="r_a51de4ded7d342456d31722493c92c969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51de4ded7d342456d31722493c92c969">tcp_init</a> (void)</td></tr>
<tr class="separator:a51de4ded7d342456d31722493c92c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b6b075c27c64dfb8c402ac961fb910" id="r_aa2b6b075c27c64dfb8c402ac961fb910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2b6b075c27c64dfb8c402ac961fb910">tcp_free</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aa2b6b075c27c64dfb8c402ac961fb910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3846a756b13214ed88ea47d0ff8279eb" id="r_a3846a756b13214ed88ea47d0ff8279eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr</a> (void)</td></tr>
<tr class="separator:a3846a756b13214ed88ea47d0ff8279eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427b11c7b98c748ec487cd43093bd2f8" id="r_ga427b11c7b98c748ec487cd43093bd2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619154658137a23839ca3b94882131ca" id="r_ga619154658137a23839ca3b94882131ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga619154658137a23839ca3b94882131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87093e137fcc53ea82a134a3f5b33623" id="r_ga87093e137fcc53ea82a134a3f5b33623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga87093e137fcc53ea82a134a3f5b33623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b94d57f1891b9287f88525a2ac561dd" id="r_ga5b94d57f1891b9287f88525a2ac561dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b94d57f1891b9287f88525a2ac561dd">tcp_shutdown</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int shut_rx, int shut_tx)</td></tr>
<tr class="separator:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f0f1ca01dbccd680eaa2d8433cd7fe" id="r_ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f0f1ca01dbccd680eaa2d8433cd7fe">tcp_abandon</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int reset)</td></tr>
<tr class="separator:ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468c2260ddb01582e966ddcf3c25ce61" id="r_ga468c2260ddb01582e966ddcf3c25ce61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5aa67bd7fc66fef43f77a55a1201ee" id="r_gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6469a15709088e80024258dbe80fcd1f" id="r_ga6469a15709088e80024258dbe80fcd1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6469a15709088e80024258dbe80fcd1f">tcp_bind_netif</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga6469a15709088e80024258dbe80fcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bb2ca7f053e73545d36b745f236d54" id="r_ga77bb2ca7f053e73545d36b745f236d54"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga77bb2ca7f053e73545d36b745f236d54">tcp_listen_with_backlog</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog)</td></tr>
<tr class="separator:ga77bb2ca7f053e73545d36b745f236d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8883f9735809f1679d744bc48f1c674a" id="r_ga8883f9735809f1679d744bc48f1c674a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8883f9735809f1679d744bc48f1c674a">tcp_listen_with_backlog_and_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> *err)</td></tr>
<tr class="separator:ga8883f9735809f1679d744bc48f1c674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c254b779db4e517cb34e41301588d" id="r_a6d2c254b779db4e517cb34e41301588d"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d2c254b779db4e517cb34e41301588d">tcp_update_rcv_ann_wnd</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6d2c254b779db4e517cb34e41301588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac0856a52b5789dc897d4c7137ec44" id="r_gabdac0856a52b5789dc897d4c7137ec44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len)</td></tr>
<tr class="separator:gabdac0856a52b5789dc897d4c7137ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a31deea4cadacd39f9485f37cfdd012" id="r_ga9a31deea4cadacd39f9485f37cfdd012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *ipaddr, u16_t port, <a class="el" href="tcp_8h.html#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a> connected)</td></tr>
<tr class="separator:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421fb42ef919018e14ae413adfee9905" id="r_a421fb42ef919018e14ae413adfee9905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr</a> (void)</td></tr>
<tr class="separator:a421fb42ef919018e14ae413adfee9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf446b07e52161b8a53cea07bc6c366d" id="r_abf446b07e52161b8a53cea07bc6c366d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf446b07e52161b8a53cea07bc6c366d">tcp_fasttmr</a> (void)</td></tr>
<tr class="separator:abf446b07e52161b8a53cea07bc6c366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae0268e59fda0665fdd08c6e77ec547" id="r_a5ae0268e59fda0665fdd08c6e77ec547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae0268e59fda0665fdd08c6e77ec547">tcp_txnow</a> (void)</td></tr>
<tr class="separator:a5ae0268e59fda0665fdd08c6e77ec547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0075b56ad4b0eca7c9d439cf150e1973" id="r_a0075b56ad4b0eca7c9d439cf150e1973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0075b56ad4b0eca7c9d439cf150e1973">tcp_process_refused_data</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0075b56ad4b0eca7c9d439cf150e1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9bb9809769197bce9b2499d55cf28c" id="r_a3d9bb9809769197bce9b2499d55cf28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9bb9809769197bce9b2499d55cf28c">tcp_segs_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a3d9bb9809769197bce9b2499d55cf28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6283651b26f74dba2444159aee88b20" id="r_ac6283651b26f74dba2444159aee88b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6283651b26f74dba2444159aee88b20">tcp_seg_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:ac6283651b26f74dba2444159aee88b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4234f1e95b6bde0e84d4ea97ae95bc" id="r_a2c4234f1e95b6bde0e84d4ea97ae95bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c4234f1e95b6bde0e84d4ea97ae95bc">tcp_setprio</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t prio)</td></tr>
<tr class="separator:a2c4234f1e95b6bde0e84d4ea97ae95bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9384b436de95d5bf8550438b9d3c8cd4" id="r_a9384b436de95d5bf8550438b9d3c8cd4"><td class="memItemLeft" align="right" valign="top">struct tcp_seg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9384b436de95d5bf8550438b9d3c8cd4">tcp_seg_copy</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a9384b436de95d5bf8550438b9d3c8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3f604fc8d20870d8cab291da5701c" id="r_a0cb3f604fc8d20870d8cab291da5701c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb3f604fc8d20870d8cab291da5701c">tcp_recv_null</a> (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a0cb3f604fc8d20870d8cab291da5701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4cb4f0391916cea723b5b5a11df2bb" id="r_a9a4cb4f0391916cea723b5b5a11df2bb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a4cb4f0391916cea723b5b5a11df2bb">tcp_alloc</a> (u8_t prio)</td></tr>
<tr class="separator:a9a4cb4f0391916cea723b5b5a11df2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e00c668b99d92113cd595647702be83" id="r_ga2e00c668b99d92113cd595647702be83"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga2e00c668b99d92113cd595647702be83">tcp_new</a> (void)</td></tr>
<tr class="separator:ga2e00c668b99d92113cd595647702be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f6955b7248c76a073cd1be461aeb5b" id="r_ga89f6955b7248c76a073cd1be461aeb5b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga89f6955b7248c76a073cd1be461aeb5b">tcp_new_ip_type</a> (u8_t type)</td></tr>
<tr class="separator:ga89f6955b7248c76a073cd1be461aeb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10926e6f76f73e17c0d37aaab3e56b6" id="r_gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void *arg)</td></tr>
<tr class="separator:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afd0b316a87a5eeff4726dc95006ed0" id="r_ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8afd0b316a87a5eeff4726dc95006ed0">tcp_recv</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a> recv)</td></tr>
<tr class="separator:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1596332b93bb6249179f3b89f24bd808" id="r_ga1596332b93bb6249179f3b89f24bd808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga1596332b93bb6249179f3b89f24bd808">tcp_sent</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a> sent)</td></tr>
<tr class="separator:ga1596332b93bb6249179f3b89f24bd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1346c4e34d3bc7c01e1b47142ab3121" id="r_gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a> err)</td></tr>
<tr class="separator:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4c3e380fc60c8fb9b3aa95eda94c62" id="r_gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a> accept)</td></tr>
<tr class="separator:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba47015098ed7ce523dcf7bdf70f7e5" id="r_gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a> poll, u8_t interval)</td></tr>
<tr class="separator:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc672b9d14a65e61040707c45302ba" id="r_a44fc672b9d14a65e61040707c45302ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fc672b9d14a65e61040707c45302ba">tcp_pcb_purge</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a44fc672b9d14a65e61040707c45302ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaef096f6a03bf5b778329bb66ee06f6" id="r_aaaef096f6a03bf5b778329bb66ee06f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaef096f6a03bf5b778329bb66ee06f6">tcp_pcb_remove</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aaaef096f6a03bf5b778329bb66ee06f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5dc2fa74855a84b2da642ba31059ea" id="r_afd5dc2fa74855a84b2da642ba31059ea"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd5dc2fa74855a84b2da642ba31059ea">tcp_next_iss</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:afd5dc2fa74855a84b2da642ba31059ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3b5396c40f32dd8b21e7d63b3e1b3" id="r_a08a3b5396c40f32dd8b21e7d63b3e1b3"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a3b5396c40f32dd8b21e7d63b3e1b3">tcp_eff_send_mss_netif</a> (u16_t sendmss, struct <a class="el" href="structnetif.html">netif</a> *outif, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *dest)</td></tr>
<tr class="separator:a08a3b5396c40f32dd8b21e7d63b3e1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c2d1ad02134c79fc72fe95ee2a703" id="r_a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d0c2d1ad02134c79fc72fe95ee2a703">tcp_netif_ip_addr_changed</a> (const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *old_addr, const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *new_addr)</td></tr>
<tr class="separator:a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4836e0b4f66439493e106a50400d1616" id="r_ga4836e0b4f66439493e106a50400d1616"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#ga4836e0b4f66439493e106a50400d1616">tcp_ext_arg_alloc_id</a> (void)</td></tr>
<tr class="separator:ga4836e0b4f66439493e106a50400d1616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e60dc02bfe0437c8da368a62e2f316" id="r_ga36e60dc02bfe0437c8da368a62e2f316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#ga36e60dc02bfe0437c8da368a62e2f316">tcp_ext_arg_set_callbacks</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, uint8_t id, const struct <a class="el" href="structtcp__ext__arg__callbacks.html">tcp_ext_arg_callbacks</a> *const callbacks)</td></tr>
<tr class="separator:ga36e60dc02bfe0437c8da368a62e2f316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58500cb2ce22438e16a37373595af318" id="r_ga58500cb2ce22438e16a37373595af318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#ga58500cb2ce22438e16a37373595af318">tcp_ext_arg_set</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, uint8_t id, void *arg)</td></tr>
<tr class="separator:ga58500cb2ce22438e16a37373595af318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7aa96ddd15fb6598523068b89f8855" id="r_gadc7aa96ddd15fb6598523068b89f8855"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html#gadc7aa96ddd15fb6598523068b89f8855">tcp_ext_arg_get</a> (const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, uint8_t id)</td></tr>
<tr class="separator:gadc7aa96ddd15fb6598523068b89f8855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5265b1df024d04287ed3edc02b1b9ccc" id="r_a5265b1df024d04287ed3edc02b1b9ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5265b1df024d04287ed3edc02b1b9ccc">tcp_ext_arg_invoke_callbacks_passive_open</a> (struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *lpcb, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *cpcb)</td></tr>
<tr class="separator:a5265b1df024d04287ed3edc02b1b9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1b42a7ac0fc173a42d575f86853d32a8" id="r_a1b42a7ac0fc173a42d575f86853d32a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></td></tr>
<tr class="separator:a1b42a7ac0fc173a42d575f86853d32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe1350e510d4308ac9969ffb4c9c81" id="r_a96fe1350e510d4308ac9969ffb4c9c81"><td class="memItemLeft" align="right" valign="top">union tcp_listen_pcbs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></td></tr>
<tr class="separator:a96fe1350e510d4308ac9969ffb4c9c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c09dbae67ccc06b659d9f1a388f911" id="r_a78c09dbae67ccc06b659d9f1a388f911"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></td></tr>
<tr class="separator:a78c09dbae67ccc06b659d9f1a388f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a522a66c5e1f1a4e28fe7a672cc64e3" id="r_a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></td></tr>
<tr class="separator:a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51515507dec664e9d69a870e6b627610" id="r_a51515507dec664e9d69a870e6b627610"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51515507dec664e9d69a870e6b627610">tcp_pcb_lists</a> []</td></tr>
<tr class="separator:a51515507dec664e9d69a870e6b627610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transmission Control Protocol for IP See also <a class="el" href="group__tcp__raw.html">TCP</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae4f0f1ca01dbccd680eaa2d8433cd7fe" name="ae4f0f1ca01dbccd680eaa2d8433cd7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f0f1ca01dbccd680eaa2d8433cd7fe">&#9670;&#160;</a></span>tcp_abandon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abandon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>reset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abandons a connection and optionally sends a RST to the remote host. Deletes the local protocol control block. This is done when a connection is killed because of shortage of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to abort </td></tr>
    <tr><td class="paramname">reset</td><td>boolean to indicate whether a reset should be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a4cb4f0391916cea723b5b5a11df2bb" name="a9a4cb4f0391916cea723b5b5a11df2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4cb4f0391916cea723b5b5a11df2bb">&#9670;&#160;</a></span>tcp_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> * tcp_alloc </td>
          <td>(</td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>prio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>priority for the new pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

</div>
</div>
<a id="a08a3b5396c40f32dd8b21e7d63b3e1b3" name="a08a3b5396c40f32dd8b21e7d63b3e1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a3b5396c40f32dd8b21e7d63b3e1b3">&#9670;&#160;</a></span>tcp_eff_send_mss_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t tcp_eff_send_mss_netif </td>
          <td>(</td>
          <td class="paramtype">u16_t</td>          <td class="paramname"><span class="paramname"><em>sendmss</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>outif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the effective send mss that can be used for a specific IP address by calculating the minimum of TCP_MSS and the mtu (if set) of the target netif (if not NULL). </p>

</div>
</div>
<a id="a5265b1df024d04287ed3edc02b1b9ccc" name="a5265b1df024d04287ed3edc02b1b9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5265b1df024d04287ed3edc02b1b9ccc">&#9670;&#160;</a></span>tcp_ext_arg_invoke_callbacks_passive_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_ext_arg_invoke_callbacks_passive_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *</td>          <td class="paramname"><span class="paramname"><em>lpcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>cpcb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calls the "passive_open" callback for all ext_args if a connection is in the process of being accepted. This is called just after the SYN is received and before a SYN/ACK is sent, to allow to modify the very first segment sent even on passive open. Naturally, the "accepted" callback of the pcb has not been called yet! </p>

</div>
</div>
<a id="abf446b07e52161b8a53cea07bc6c366d" name="abf446b07e52161b8a53cea07bc6c366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf446b07e52161b8a53cea07bc6c366d">&#9670;&#160;</a></span>tcp_fasttmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_fasttmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data previously "refused" by upper layer (application) and sends delayed ACKs or pending FINs.</p>
<p>Automatically called from <a class="el" href="#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a id="aa2b6b075c27c64dfb8c402ac961fb910" name="aa2b6b075c27c64dfb8c402ac961fb910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b6b075c27c64dfb8c402ac961fb910">&#9670;&#160;</a></span>tcp_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a tcp pcb </p>

</div>
</div>
<a id="a51de4ded7d342456d31722493c92c969" name="a51de4ded7d342456d31722493c92c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de4ded7d342456d31722493c92c969">&#9670;&#160;</a></span>tcp_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize this module. </p>

</div>
</div>
<a id="a4d0c2d1ad02134c79fc72fe95ee2a703" name="a4d0c2d1ad02134c79fc72fe95ee2a703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0c2d1ad02134c79fc72fe95ee2a703">&#9670;&#160;</a></span>tcp_netif_ip_addr_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_netif_ip_addr_changed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>old_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga335a8c9df66319e88a1a529047ce0a1e">ip_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>new_addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called from <a class="el" href="netif_8c.html">netif.c</a> when address is changed or netif is removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_addr</td><td>IP address of the netif before change </td></tr>
    <tr><td class="paramname">new_addr</td><td>IP address of the netif after change or NULL if netif has been removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd5dc2fa74855a84b2da642ba31059ea" name="afd5dc2fa74855a84b2da642ba31059ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5dc2fa74855a84b2da642ba31059ea">&#9670;&#160;</a></span>tcp_next_iss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_next_iss </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a new initial sequence number for new connections.</p>
<dl class="section return"><dt>Returns</dt><dd>u32_t pseudo random sequence number </dd></dl>

</div>
</div>
<a id="a44fc672b9d14a65e61040707c45302ba" name="a44fc672b9d14a65e61040707c45302ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc672b9d14a65e61040707c45302ba">&#9670;&#160;</a></span>tcp_pcb_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges a TCP PCB. Removes any buffered data and frees the buffer memory (pcb-&gt;ooseq, pcb-&gt;unsent and pcb-&gt;unacked are freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is not deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaef096f6a03bf5b778329bb66ee06f6" name="aaaef096f6a03bf5b778329bb66ee06f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaef096f6a03bf5b778329bb66ee06f6">&#9670;&#160;</a></span>tcp_pcb_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **</td>          <td class="paramname"><span class="paramname"><em>pcblist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcblist</td><td>PCB list to purge. </td></tr>
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is NOT deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0075b56ad4b0eca7c9d439cf150e1973" name="a0075b56ad4b0eca7c9d439cf150e1973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0075b56ad4b0eca7c9d439cf150e1973">&#9670;&#160;</a></span>tcp_process_refused_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_process_refused_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass pcb-&gt;refused_data to the recv callback </p>

</div>
</div>
<a id="a0cb3f604fc8d20870d8cab291da5701c" name="a0cb3f604fc8d20870d8cab291da5701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb3f604fc8d20870d8cab291da5701c">&#9670;&#160;</a></span>tcp_recv_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_recv_null </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default receive callback that is called if the user didn't register a recv callback for the pcb. </p>

</div>
</div>
<a id="a9384b436de95d5bf8550438b9d3c8cd4" name="a9384b436de95d5bf8550438b9d3c8cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9384b436de95d5bf8550438b9d3c8cd4">&#9670;&#160;</a></span>tcp_seg_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct tcp_seg * tcp_seg_copy </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the given TCP segment. The pbuf and data are not copied, only the pointers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>the old tcp_seg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of seg </dd></dl>

</div>
</div>
<a id="ac6283651b26f74dba2444159aee88b20" name="ac6283651b26f74dba2444159aee88b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6283651b26f74dba2444159aee88b20">&#9670;&#160;</a></span>tcp_seg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_seg_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a TCP segment (tcp_seg structure).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>single tcp_seg to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d9bb9809769197bce9b2499d55cf28c" name="a3d9bb9809769197bce9b2499d55cf28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9bb9809769197bce9b2499d55cf28c">&#9670;&#160;</a></span>tcp_segs_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_segs_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *</td>          <td class="paramname"><span class="paramname"><em>seg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates a list of TCP segments (tcp_seg structures).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>tcp_seg list of TCP segments to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c4234f1e95b6bde0e84d4ea97ae95bc" name="a2c4234f1e95b6bde0e84d4ea97ae95bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4234f1e95b6bde0e84d4ea97ae95bc">&#9670;&#160;</a></span>tcp_setprio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_setprio </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>prio</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority of a connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to manipulate </td></tr>
    <tr><td class="paramname">prio</td><td>new priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a421fb42ef919018e14ae413adfee9905" name="a421fb42ef919018e14ae413adfee9905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421fb42ef919018e14ae413adfee9905">&#9670;&#160;</a></span>tcp_slowtmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_slowtmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called every 500 ms and implements the retransmission timer and the timer that removes PCBs that have been in TIME-WAIT for enough time. It also increments various timers such as the inactivity timer in each PCB.</p>
<p>Automatically called from <a class="el" href="#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a id="a3846a756b13214ed88ea47d0ff8279eb" name="a3846a756b13214ed88ea47d0ff8279eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3846a756b13214ed88ea47d0ff8279eb">&#9670;&#160;</a></span>tcp_tmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_tmr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called periodically to dispatch TCP timers. </p>

</div>
</div>
<a id="a5ae0268e59fda0665fdd08c6e77ec547" name="a5ae0268e59fda0665fdd08c6e77ec547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae0268e59fda0665fdd08c6e77ec547">&#9670;&#160;</a></span>tcp_txnow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_txnow </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set </p>

</div>
</div>
<a id="a6d2c254b779db4e517cb34e41301588d" name="a6d2c254b779db4e517cb34e41301588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2c254b779db4e517cb34e41301588d">&#9670;&#160;</a></span>tcp_update_rcv_ann_wnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_update_rcv_ann_wnd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *</td>          <td class="paramname"><span class="paramname"><em>pcb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the state that tracks the available window space to advertise.</p>
<p>Returns how much extra window would be advertised if we sent an update now. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a78c09dbae67ccc06b659d9f1a388f911" name="a78c09dbae67ccc06b659d9f1a388f911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c09dbae67ccc06b659d9f1a388f911">&#9670;&#160;</a></span>tcp_active_pcbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_active_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs that are in a state in which they accept or send data. </p>

</div>
</div>
<a id="a1b42a7ac0fc173a42d575f86853d32a8" name="a1b42a7ac0fc173a42d575f86853d32a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b42a7ac0fc173a42d575f86853d32a8">&#9670;&#160;</a></span>tcp_bound_pcbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_bound_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs bound but not yet (connected || listening) </p>

</div>
</div>
<a id="a96fe1350e510d4308ac9969ffb4c9c81" name="a96fe1350e510d4308ac9969ffb4c9c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fe1350e510d4308ac9969ffb4c9c81">&#9670;&#160;</a></span>tcp_listen_pcbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union tcp_listen_pcbs_t tcp_listen_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs in LISTEN state </p>

</div>
</div>
<a id="a51515507dec664e9d69a870e6b627610" name="a51515507dec664e9d69a870e6b627610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51515507dec664e9d69a870e6b627610">&#9670;&#160;</a></span>tcp_pcb_lists</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>** const tcp_pcb_lists[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {&amp;<a class="code hl_variable" href="#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a>.pcbs, &amp;<a class="code hl_variable" href="#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a>,</div>
<div class="line">         &amp;<a class="code hl_variable" href="#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a>, &amp;<a class="code hl_variable" href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></div>
<div class="line">}</div>
<div class="ttc" id="atcp_8c_html_a1b42a7ac0fc173a42d575f86853d32a8"><div class="ttname"><a href="#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></div><div class="ttdeci">struct tcp_pcb * tcp_bound_pcbs</div><div class="ttdef"><b>Definition</b> tcp.c:171</div></div>
<div class="ttc" id="atcp_8c_html_a78c09dbae67ccc06b659d9f1a388f911"><div class="ttname"><a href="#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></div><div class="ttdeci">struct tcp_pcb * tcp_active_pcbs</div><div class="ttdef"><b>Definition</b> tcp.c:176</div></div>
<div class="ttc" id="atcp_8c_html_a96fe1350e510d4308ac9969ffb4c9c81"><div class="ttname"><a href="#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></div><div class="ttdeci">union tcp_listen_pcbs_t tcp_listen_pcbs</div><div class="ttdef"><b>Definition</b> tcp.c:173</div></div>
<div class="ttc" id="atcp_8c_html_a9a522a66c5e1f1a4e28fe7a672cc64e3"><div class="ttname"><a href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></div><div class="ttdeci">struct tcp_pcb * tcp_tw_pcbs</div><div class="ttdef"><b>Definition</b> tcp.c:178</div></div>
</div><!-- fragment --><p>An array with all (non-temporary) PCB lists, mainly used for smaller code size </p>

</div>
</div>
<a id="a9a522a66c5e1f1a4e28fe7a672cc64e3" name="a9a522a66c5e1f1a4e28fe7a672cc64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a522a66c5e1f1a4e28fe7a672cc64e3">&#9670;&#160;</a></span>tcp_tw_pcbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_tw_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs in TIME-WAIT state </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_aebb8dcc11953d78e620bbef0b9e2183.html">core</a></li><li class="navelem"><a class="el" href="tcp_8c.html">tcp.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
